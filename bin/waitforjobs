#!/usr/bin/perl

# 11.04.2010 12:26:08 EDT
# Harm van Bakel <hvbakel@gmail.com>

# GLOBALS
$ENV{QSTAT}       ||= '/usr/local/bin/qstat';
$ENV{SERVER_LOGS} ||= '/var/spool/torque/server_logs/';

# MODULES
use strict;
use warnings;
use Getopt::Long;

# GET PARAMETERS
my $sHelp        = 0;
my $sUser        = $ENV{USER};
GetOptions("help!"   => \$sHelp,
           "user:s"  => \$sUser);

# PRINT HELP
$sHelp = 1 unless(@ARGV>0);
if ($sHelp) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName [-u] <semaphore-file>
   
   This script waits for all jobs specified in the semaphore
   files to finish. It can be used as part of a shell script
   to allow a certain set of jobs to finish before starting
   a new job submission.

   Options: 
    -u -user <string>
      Username. Default: $sUser
    -help
      This help message
   
HELP
}
my $sFile = $ARGV[0];

##########
## MAIN ##
##########

# Initialize exit status hash
my %hExitStatus = (-1   => '-1  (job exec failed, before files, no retry)', 
                   -2   => '-2  (job exec failed, after files, no retry)', 
                   -3   => '-3  (job execution failed, do retry)', 
                   -4   => '-4  (job aborted on MOM initialization)',
                   -5   => '-5  (job aborted on MOM init, chkpt, no migrate)', 
                   -6   => '-6  (job aborted on MOM init, chkpt, ok migrate)', 
                   -7   => '-7  (job restart failed)', 
                   -8   => '-8  (exec() of user command failed)',
                   1    => '1   (general error, check job output file)',
                   2    => '2   (misuse of shell builtins)',
                   126  => '126 (command invoked cannot execute)',
                   127  => '127 (command not found)',
                   130  => '130 (script terminated by Ctrl+C)',
                   139  => '139 (Segmentation fault)',
                   271  => '271 (SIGTERM, job likely exceeded run time or memory limits)');

# Read job IDs from semaphore file
my %hJobIDs;
my $nHistoryDepth = 1;
open IN, $sFile or die "Error: can't open '$sFile': $!\n";
while (<IN>){
   next if (/^\s*$/);
   next if (/^ *#/);
   s/[\n\r]+$//;
   my ($nJobID, $nRunTime) = split /\t/;
   die "Error: jobID should be a number on line $.\n"   unless($nJobID =~ /^\d+$/);
   die "Error: runtime should be a number on line $.\n" unless($nRunTime =~ /^\d+$/);
   $hJobIDs{$nJobID} = 0;
   $nHistoryDepth = $nRunTime if ($nRunTime > $nHistoryDepth);
}
close IN;


# Start querying jobs
my %hFinishedJobs;
while (keys %hJobIDs){
   my $rhJobsInQueue = get_user_job_ids($sUser);
   
   # Figure out which jobs finished
   foreach my $nJobID (keys %hJobIDs){ 
      unless (exists $rhJobsInQueue->{$nJobID}){
         unless (exists $hFinishedJobs{$nJobID}){
            delete($hJobIDs{$nJobID});
            $hFinishedJobs{$nJobID}++;
         }
      }
   }
   sleep 15 if(keys %hJobIDs);
}

# Get the status for the finished jobs from the server logs
my $rhExitStatus = tracejob_exitstatus(\%hFinishedJobs, $nHistoryDepth);

# Process the exit status results for errors
my @asMissing;
my @asErrors;
foreach my $nJobID (sort {$a <=> $b} keys %hFinishedJobs){
   my $sExitStatus = 'NA';
   $sExitStatus    = $rhExitStatus->{$nJobID}   if (exists $rhExitStatus->{$nJobID});
   if ($sExitStatus eq 'NA'){
      push @asMissing, " $nJobID";
   }
   else{
      $sExitStatus    = $hExitStatus{$sExitStatus} if (exists $hExitStatus{$sExitStatus});
      push @asErrors, "Job $nJobID failed with status $sExitStatus" if ($sExitStatus);
   }
}

# And finally print the result
if (@asErrors and @asMissing){
   print STDERR "No information found in server logs for the following jobs, try increasing -h:\n";
   print STDERR format_elements(@asMissing);
   die join("\n", @asErrors), "\n";
}
elsif (@asErrors){
   die join("\n", @asErrors), "\n";
}
elsif (@asMissing){
   print STDERR "No information found in server logs for the following jobs, try increasing -h:\n";
   die format_elements(@asMissing);
}
else{
   print STDERR "All jobs completed successfully\n";
}


#################
## SUBROUTINES ##
#################

# get_user_job_ids
#
# Get currently running and queued jobs
sub get_user_job_ids {
   my ($sUser) = @_;
   my %hReturn;
   
   open QSTAT, "$ENV{QSTAT} -u $sUser |" or die "Error: can't run qstat\n";
   while (<QSTAT>){
      if (/^\d+/){
         my $sJobID = (split / +/)[0];
         $sJobID =~ s/\..*$//;
         $hReturn{$sJobID} = 0;
      }
   }
   close QSTAT;
   return \%hReturn;
}

# tracejob_exitstatus
#
# Parse the exit status of a set of jobs from the server logs
sub tracejob_exitstatus {
   my ($rhJobHash, $nHistoryDepth) = @_;
   my %hExitStatus;
   
   open FIND, "find $ENV{SERVER_LOGS} -mtime -${nHistoryDepth} -type f |" or die "Error: can't collect server log files: $!\n";
   while (<FIND>){
      next if (/^\s*$/);
      next if (/^ *#/);
      s/[\n\r]+$//;
      open LOG, $_ or die "Error: can't process server log file '$_': $!\n";
      while (<LOG>){
         next if (/^\s*$/);
         next if (/^ *#/);
         s/[\n\r]+$//;
         if (/Exit_status=([+-]?\d+)/){
            my ($nJobID,$nExitStatus) = (split /;/)[4,5];
            $nJobID      =~ s/\..*$//;
            $nExitStatus =~ s/ .*$//;
            $nExitStatus =~ s/^.*=//;
            $hExitStatus{$nJobID} = $nExitStatus if(exists $rhJobHash->{$nJobID});
         }
      }
      close LOG;
   }
   close FIND;
   return \%hExitStatus;
}


# format_elements
#
# Put six array elements on each line
sub format_elements {
   my @asArray = @_;
   my $sReturn = "";
   my $nCount = 8;
   foreach my $sElement (@asArray){
      $sReturn .= $sElement;
      $nCount   = $nCount ? $nCount-1 : 6;
      $sReturn .= "\n" if ( ($nCount==0) or ($sElement eq $asArray[$#asArray]) );
   }
   return $sReturn;
}
