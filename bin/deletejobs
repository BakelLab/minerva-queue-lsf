#!/usr/bin/perl

# 30.09.2012 10:45:44 EDT
# Harm van Bakel <hvbakel@gmail.com>

# MODULES
use strict;
use warnings;
use Getopt::Long;
use Env '@PATH';

# GLOBALS
$ENV{QSTAT} ||= "qstat";

# GET PARAMETERS
my $sHelp       = 0;
my $sName       = "";
my $sQueue      = "";
my $sState      = "";
my $nBeginRange = 0;
my $nEndRange   = 0;
my $flAll       = 0;
GetOptions("help!"     => \$sHelp,
           "jobname:s" => \$sName,
           "queue:s"   => \$sQueue,
           "state:s"   => \$sState,
           "begin:i"   => \$nBeginRange,
           "end:i"     => \$nEndRange,
           "all!"      => \$flAll);

# PRINT HELP
$sHelp = 1 unless($sName or $sQueue or $sState or $nBeginRange or $nEndRange or $flAll);
if ($sHelp) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName
   
   Delete running and/or queued jobs based on a set of criteria.
   Use multiple options together to narrow down your selection.
   
   Options:
    -j --jobname <string>
      Select jobs by name
    -q --queue <string>
      Select jobs by queue
    -s --state <string>
      Select jobs by state
    -b --begin <integer>
      Begin of job identifier range to delete. If end is not 
      defined, all jobs >= than this ID will be deleted.
    -e --end <integer>
      End of job identifier range. If start is not defined,
      all jobs <= to this ID will be deleted.
    -a --all
      Delete ALL jobs
    -help
      This help message
   
HELP
}


##########
## MAIN ##
##########

# Check if qstat exists
my $flQstatExists = grep -x "$_/$ENV{QSTAT}", @PATH;
die "Error: qstat is not installed on this system\n" unless($flQstatExists);

# Format prompt string
my $sPrompt = "";
unless ($flAll){
   $sPrompt .= " in queue '$sQueue'" if ($sQueue);
   $sPrompt .= " in state '$sState'" if ($sState);
   $sPrompt .= " with name '$sName'" if ($sName);
   $sPrompt .= " with IDs >= $nBeginRange" if ($nBeginRange);
   $sPrompt .= " with IDs <= $nEndRange" if ($nEndRange);
}

# Ask to proceed
my $nPrompt = 1;
while($nPrompt){
   my $sProceed = &prompt_user("Delete all your jobs$sPrompt (yes/no)?", 'no');
   if (lc($sProceed) eq 'yes'){
      $nPrompt=0;
   }
   elsif (lc($sProceed) eq 'no'){
      die "No jobs were deleted.\n";
   }
   else{
      print STDERR "Please answer either 'yes' or 'no\n";
   }
}

# Start deleting according to the selection
my $nDeleteCount;
open QSTAT, "$ENV{QSTAT} -u $ENV{USER} | sort -k10,10 |" or die "Error: couldn't run qstat: $!\n";
while (<QSTAT>){
   next unless /^\d+/;
   my ($jobid,$user,$queue,$jobname,$sessid,$nds,$tsk,$mem,$timereq,$state,$timepassed) = split /\s+/;
   if ($state eq 'R' or $state eq 'Q'){
      $jobid =~ s/\..*$//;
      my $flProceed = 1;
      unless($flAll){
         if ($sName){
            $flProceed = 0 unless ($sName eq $jobname);
         }
         if ($sQueue){
            $flProceed = 0 unless ($sQueue eq $queue);
         }
         if ($sState){
            $flProceed = 0 unless ($sState eq $state);
         }
         if ($nBeginRange){
            $flProceed = 0 unless ($jobid >= $nBeginRange);
         }
         if ($nEndRange){
            $flProceed = 0 unless ($jobid <= $nEndRange);
         }
      }
      if ($flProceed){
         print "Deleting $_";
         $nDeleteCount++;
         `qdel $jobid`;
      }
   }
}
close QSTAT;

# Print stats
if ($nDeleteCount){
   my $sPlural = $nDeleteCount > 1 ? 'jobs were' : 'job was';
   print "$nDeleteCount $sPlural deleted\n";
}
else{
   print "No jobs were deleted\n";
}

#################
## SUBROUTINES ##
#################

# prompt_user ($promptString, $defaultValue)
#
# if there is a default value, use the first print statement;
# if no default is provided, print the second string.              
sub prompt_user {
   my ($promptString,$defaultValue) = @_;

   if ($defaultValue) {
      print $promptString, " [ ", $defaultValue, " ] : ";
   } else {
      print $promptString, " : ";
   }
   $| = 1;               # force a flush after our print
   $_ = <STDIN>;         # get the input from STDIN (presumably the keyboard)
   chomp;
   if ("$defaultValue") {
      return length($_) ? $_ : $defaultValue;    # return $_ if it has a value
   } else {
      return $_;
   }
}
