#!/usr/bin/perl

# 11.04.2010 12:26:08 EDT
# Harm van Bakel <hvbakel@gmail.com>

# MODULES
use strict;
use warnings;
use Getopt::Long;

# GLOBALS
$ENV{PBS_OUTPUT}  ||= "$ENV{HOME}/pbs-output";    # Folder with pbs output files
$ENV{SERVER_LOGS} ||= '/var/lib/torque/server_logs/';

# ARGUMENTS
my $sHelp         = 0;
my $nFileCount    = 0;
my $sPrefix       = '';
my $flVerbose     = 0;
my $flRemove      = 0;
GetOptions("help!"  => \$sHelp,
           "n:i"    => \$nFileCount,
           "p:s"    => \$sPrefix,
           "v!"     => \$flVerbose,
           "r!"     => \$flRemove);
           
# PRINT HELP
my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
if ($sHelp) {
    die <<HELP

    $sScriptName [ -n | -i ]

    Check the exit status of recently finished jobs. Can be used to make sure that
    all jobs in a large job submission finished successfully.
    
    Options:
    -p <string>
      Show exit status of jobs whose output file name starts with a specified prefix
    -n <integer>
      Show exit status of the n most recently finished jobs (can be used in combination with -p)
    -v
      Show output for failed jobs
    -r
      Remove the output for failed or missing jobs
    
    -help
      This help message
      
HELP
}


##########
## MAIN ##
##########

# Fail gracefully if the log folders don't exist
die "Error: The job output folder does not exist\n" unless (-d $ENV{PBS_OUTPUT});

# Sort the output files by modification date
opendir my($dir), $ENV{PBS_OUTPUT} or die "Can't open $ENV{PBS_OUTPUT} : $!\n";
my @asFiles              = grep { -f "$ENV{PBS_OUTPUT}/$_" } readdir $dir;
my $nTotalJobOutputFiles = scalar(@asFiles);
@asFiles                 = sort { eval('-M "$ENV{PBS_OUTPUT}/$a" <=> -M "$ENV{PBS_OUTPUT}/$b"') } @asFiles;

# Filter on prefix
if ($sPrefix) {
   my @asTmpFiles;
   foreach my $sFile (@asFiles){
      push @asTmpFiles, $sFile if ($sFile =~ /$sPrefix/);
   }
   @asFiles = @asTmpFiles;
}

# Set the number of files to check
if ($nFileCount){
   $nFileCount = scalar(@asFiles) if (scalar(@asFiles)<$nFileCount);
}
else{
   $nFileCount = scalar(@asFiles);
}

# Check if we have any output files to examine
if($nFileCount == 0){
   if ($nTotalJobOutputFiles){
      die "No job output files meeting criteria\n"
   }
   else{
      die "No job output files found\n";
   }
}

# Parse files for exit status info
my %hExitStatus;
my @asErrors;
my @asMissing;
for (my $i=$nFileCount-1; $i>=0; $i--){
   my $nExitStatus = "NA";
   open JOB, "tail $ENV{PBS_OUTPUT}/$asFiles[$i]|" or die "Error: can't open '$ENV{PBS_OUTPUT}/$asFiles[$i]'\n";
   while (<JOB>){
      $nExitStatus = $1 if(/\=\=\> Exit status    \: (.*)$/);
   }
   close JOB;
   
   # Check exit status
   if ($nExitStatus eq 'NA'){
      push @asMissing, $asFiles[$i];
   }
   elsif ($nExitStatus =~ /^0 /){
      next;
   }
   else{
      push @asErrors, $asFiles[$i];
      $hExitStatus{$asFiles[$i]} = $nExitStatus;
   }
}

if ($flRemove){
   # Remove the output of jobs with errors
   if (@asErrors or @asMissing){
      my $nCount = scalar(@asErrors) + scalar(@asMissing);
      my $sCount = $nCount==1 ? "1 job" : "$nCount jobs";
      foreach my $sJob (@asErrors, @asMissing){
         unlink glob "$ENV{PBS_OUTPUT}/$sJob";
      }
      print "\nRemoved output of $sCount with non-zero or missing exit status\n\n";
   }
   else{
      print "\nNo jobs with non-zero or missing exit status found for removal\n\n";
   }
}
else{
   # Print the result
   if (@asErrors and @asMissing){
      print_missing(@asMissing);
      print_errors(\@asErrors, \%hExitStatus, $flVerbose);
      my $nOKcount = $nFileCount - @asMissing - @asErrors;
      print other_job_stats($nOKcount, $nFileCount);
   }
   elsif (@asErrors){
      print_errors(\@asErrors, \%hExitStatus, $flVerbose);
      my $nOKcount = $nFileCount - @asErrors;
      print other_job_stats($nOKcount, $nFileCount);
   }
   elsif (@asMissing){
      print_missing(@asMissing);
      my $nOKcount = $nFileCount - @asMissing;
      print other_job_stats($nOKcount, $nFileCount);
   }
   else{
      if ($nFileCount == scalar($nTotalJobOutputFiles)){
         print "\nAll $nFileCount jobs with output in $ENV{HOME}/pbs-output exited normally\n\n";
      }
      else{
         if ($nFileCount == 1){
            print "\nThe last job with output in $ENV{HOME}/pbs-output exited normally\n\n";
         }
         else{
            print "\nThe last $nFileCount jobs with output in $ENV{HOME}/pbs-output exited normally\n\n";
         }
      }
   }
}


#################
## SUBROUTINES ##
#################

# other_job_stats
#
# other_job_stats
sub other_job_stats {
   my ($nOKcount, $nFileCount) = @_;
   my $sMessage = $nOKcount==1 ? "$nOKcount other job" : "$nOKcount other jobs";
   return "\n$sMessage exited normally ($nFileCount job output files examined).\n\n";
}


# print_missing
#
# Print list of IDs that have no info in server logs
sub print_missing {
   my @asArray = @_;
   print "\n-------------------------------------------------------\n";
   print "| No exit information found in these job output files |\n";
   print "-------------------------------------------------------\n";
   my $sRelPath = $ENV{PBS_OUTPUT};
   $sRelPath =~ s/^$ENV{HOME}/~/;

   # Process missing
   foreach my $sJobFile (@asArray){
      if ($flVerbose){
         print "  \e[1;31m$sRelPath/$sJobFile\e[0m\n";
         my $sJobOutput = join("/", $ENV{PBS_OUTPUT}, $sJobFile);
         open OUT, $sJobOutput or die "Can't open $sJobOutput: $!\n";
         while (<OUT>){print "     $_";}
         close OUT;
      }
      else{
         print "  $sRelPath/$sJobFile\n";
      }
   }

}


# print_errors
#
# Print jobs that exited with an error
sub print_errors {
   my ($raErrors, $rhExitStatus, $flVerbose) = @_;
   print "\n-------------------------------------------------------\n";
   print "| The following jobs failed with non-zero exit status |\n";
   print "-------------------------------------------------------\n";
   my $sRelPath = $ENV{PBS_OUTPUT};
   $sRelPath =~ s/^$ENV{HOME}/~/;

   # Process errors
   foreach my $sJobFile (@$raErrors){
      if ($flVerbose){
         print "  \e[1;31m$sRelPath/$sJobFile ==> $rhExitStatus->{$sJobFile}\e[0m\n";
         my $sJobOutput = join("/", $ENV{PBS_OUTPUT}, $sJobFile);
         open OUT, $sJobOutput or die "Can't open $sJobOutput: $!\n";
         while (<OUT>){print "     $_";}
         close OUT;
      }
      else{
         print "  $sRelPath/$sJobFile ==> $rhExitStatus->{$sJobFile}\n";
      }
   }
}
