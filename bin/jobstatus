#!/usr/bin/perl

# 18.01.2010 12:52:40 EST
# Harm van Bakel <hvbakel@gmail.com>

# MODULES
use strict;
use warnings;
use Getopt::Long;
use Env '@PATH';

# GLOBAL
$ENV{QSTAT} ||= "qstat";
$ENV{QMGR}  ||= "qmgr";
my @asStatusCodes = ('R','Q','H','T','W','S','E','C');
my %hStatusCodes  = ('R'=>'Running','Q'=>'Queued','H'=>'Held','T'=>'Moving',
                     'W'=>'Waiting','S'=>'Suspend','E'=>'Exiting','C'=>'Complete');

# GET PARAMETERS
my $flHelp       = 0;
my $flProcInfo   = 0;
my $flGpuInfo    = 0;
my $sServer      = "";
GetOptions("help!"      => \$flHelp,
           "cpuinfo!"   => \$flProcInfo,
           "pcpuinfo!"  => \$flProcInfo,
           "gpuinfo!"   => \$flGpuInfo,
           "server:s"   => \$sServer);

# PRINT HELP
if ($flHelp) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName [-scgh]

   Gives a brief summary of all running and queued jobs.
   
   Options: 
    -s -server <string>
      Show queue information for a different server
    -c -cpuinfo
      Show processors in use rather than jobs
    -g -gpuinfo
      Show GPUs in use rather than jobs
    -h -help
      This help message
   
HELP
}


##########
## MAIN ##
##########

# Check whether the qstat binary exist in path
my $flQstatExists = grep -x "$_/$ENV{QSTAT}", @PATH;
die "Error: qstat is not installed on this system\n" unless($flQstatExists);

# Collect job or CPU count stats
my %hUserStats;
my %hQueueStats;
my %hTotalStats;
my $flPUinfo = $flProcInfo + $flGpuInfo;
my @asFailedCpuStats;
my $sQueueCmd = $sServer ? join('', $ENV{QSTAT}, ' @',$sServer) : $ENV{QSTAT};
if ($flPUinfo){
   my ($user,$queue,$status,$hostlist,$reslist,$ncpus,$arrayreq) = ("","","","","","","");
   my $rhDefaultPUs = get_queue_default_pu_stats();
   my %hRunningJobArrayPUs;
   open QSTAT, "$sQueueCmd -t -f -1 |" or die "Error: could not run 'qstat' to get job status report: $!\n";
   while (<QSTAT>){
      s/[\n\r]+$//;
      if(/^\s+Job_Owner = (\S+)@.*$/)        { $user     = $1; }
      if(/^\s+job_state = (\S)$/)            { $status   = $1; }
      if(/^\s+queue = (\S+)$/)               { $queue    = $1; }
      if(/^\s+exec_host = (.+)$/)            { $hostlist = $1; }
      if(/^\s+Resource_List.nodes = (.+)$/)  { $reslist  = $1; }
      if(/^\s+Resource_List.ncpus = (\d+)$/) { $ncpus    = $1; }
      if(/^\s+job_array_request = (.+)$/)    { $arrayreq = $1; }
      
      if ( (/^Job Id: / or eof) and $user){
         $user = "*\e[0;46m${user}\e[0m" if ($user eq $ENV{USER});
         my ($rescpus,$resgpus) = (0,0,0);
         
         # First try to obtain the number of CPUs and GPUs from the resource list, if available
         if ($reslist){
            ($rescpus,$resgpus) = parse_cpus_gpus_from_resource_list($reslist);
         }
         
         # Second, try to get the number of CPUs from the host list (for running jobs)
         if ($rescpus==0 and $hostlist){
            my @cpus = split /\+/, $hostlist;
            $rescpus = scalar(@cpus);
         }
         
         # Third, try to parse the ncpu field, if available
         if ($rescpus==0 and $ncpus){
            $rescpus = $ncpus;
         }
         
         # Fourth, if we don't have any cpus or gpus at this stage we either
         #  - try to derive the cpu count from already running jobs in the same array or
         #  - assume the default cpu and gpu count for the queue
         if ($rescpus==0 and $resgpus==0){
            if (exists $hRunningJobArrayPUs{$arrayreq}){
               $rescpus = $hRunningJobArrayPUs{$arrayreq}{cpus};
               $resgpus = $hRunningJobArrayPUs{$arrayreq}{gpus};
            }
            else{
               if (exists $rhDefaultPUs->{$queue}){
                  $rescpus = $rhDefaultPUs->{$queue}{cpus};
                  $resgpus = $rhDefaultPUs->{$queue}{gpus};
               }
            }
         }
         else{
            if($arrayreq){
               $hRunningJobArrayPUs{$arrayreq}{cpus} = $rescpus;
               $hRunningJobArrayPUs{$arrayreq}{gpus} = $resgpus;
            }
         }
         
         # Check if we have collected any CPU or GPU info at this stage
         if ($rescpus==0 and $resgpus==0){
            push @asFailedCpuStats, "   $user   $status   $queue   $hostlist   $reslist   $ncpus";
         }
         
         # Collect all requested processing unit counts (gpus and/or cpus)
         my $nTotPUs = 0;
         $nTotPUs += $rescpus if ($flProcInfo);
         $nTotPUs += $resgpus if ($flGpuInfo);
         
         # Increment user stats
         $hUserStats{$user}{$queue}{$status} += $nTotPUs;
         $hQueueStats{$queue}{$status}       += $nTotPUs;
         $hTotalStats{$status}               += $nTotPUs;
         
         # Clear variables
         ($user,$queue,$status,$hostlist,$reslist,$ncpus,$arrayreq) = ("","","","","","","");
      }
   }
   close QSTAT;
}
else{
   open QSTAT, "$sQueueCmd -t |" or die "Error: could not run 'qstat' to get job status report: $!\n";
   while (<QSTAT>){
      next if (/^Job id/);
      next if (/^---/);
      s/[\n\r]+$//;
      my ($id,$job_name,$user,$time_elapsed,$status,$queue) = split /\s+/, $_, -1;
      if ($queue){
         $user = "*\e[0;46m${user}\e[0m" if ($user eq $ENV{USER});
         $hUserStats{$user}{$queue}{$status}++;
         $hQueueStats{$queue}{$status}++;
         $hTotalStats{$status}++;
      }
   }
   close QSTAT;
}

# Figure out which columns should be displayed
my @asJobStatus;
foreach my $sStatus (@asStatusCodes){
   push @asJobStatus, $sStatus if (exists $hTotalStats{$sStatus});
}

# Print header
my $sHeader = sprintf("%-12s %-14s", 'User', 'Queue');
foreach my $sStatus (@asJobStatus){
   $sHeader .= sprintf(" %-8s", $hStatusCodes{$sStatus});
}
print '=' x length($sHeader) . "\n$sHeader\n" . '-' x length($sHeader) . "\n";

# Print user stats
foreach my $user (sort(keys(%hUserStats))) {
   foreach my $queue (sort(keys(%{$hUserStats{$user}}))) {
      if ($user =~ /^\*/){
         my $formatted = $user;
         $formatted =~ s/^\*//;
         print sprintf("%-23s %-14s", $formatted, $queue);
      }
      else{
         print sprintf("%-12s %-14s", $user, $queue);
      }
      foreach my $status (@asJobStatus){
         if (exists($hUserStats{$user}{$queue}{$status})){
            print sprintf(" %-8s", $hUserStats{$user}{$queue}{$status});
         }
         else{
            print sprintf(" %-8s", 0);
         }
      }
      print "\n";
   }
}

# Print queue stats
print '-' x length($sHeader) . "\n";
foreach my $queue (sort(keys(%hQueueStats))) {
   print sprintf("%-12s %-14s", '', $queue);
   foreach my $status (@asJobStatus){
      if (exists($hQueueStats{$queue}{$status})){
         print sprintf(" %-8s", $hQueueStats{$queue}{$status});
      }
      else{
         print sprintf(" %-8s", 0);
      }
   }
   print "\n";
}

# Print totals
print " " x 13 . "-" x (length($sHeader)-13) . "\n";
print sprintf("%-12s %-14s", '', 'totals');
foreach my $status (@asJobStatus){
   if (exists($hTotalStats{$status})){
      print sprintf(" %-8s", $hTotalStats{$status});
   }
   else{
      print sprintf(" %-8s", 0);
   }
}
print "\n";

# Make sure we warn in case of issues with CPU counts
if (@asFailedCpuStats){
   my $nFailedCpuStats = scalar(@asFailedCpuStats);
   if ($nFailedCpuStats == 1){
      warn("Warning: could not determine accurate CPU or GPU counts for 1 job:\n")
   }
   else{
      warn("Warning: could not determine accurate CPU or GPU counts for $nFailedCpuStats jobs:\n")
   }
   my $nFailDetailCount = $nFailedCpuStats < 5 ? $nFailedCpuStats : 5;
   for (my $i=0 ; $i<$nFailDetailCount ; $i++){
      warn("$asFailedCpuStats[$i]\n");
   }
   print "Further details omitted\n" if ($nFailedCpuStats > $nFailDetailCount);
}


###############
# SUBROUTINES #
###############

# get_queue_default_pu_stats
#
# Get the default PU stats for queued jobs
sub get_queue_default_pu_stats {
   my %hDefaultPUs;
   open QMGR, "$ENV{QMGR} -c 'print server' |" or die "Error: can't run qmgr: $!\n";
   while (<QMGR>){
      if (/resources_default.nodes/){
         my (@asLine) = split / /;
         my $sQueue     = $asLine[2];
         my ($rescpus, $resgpus) = parse_cpus_gpus_from_resource_list($asLine[$#asLine]);
         if ($rescpus or $resgpus){
            $hDefaultPUs{$sQueue}{cpus} = $rescpus;
            $hDefaultPUs{$sQueue}{gpus} = $resgpus;
         }
      }
   }
   close QMGR;
   return(\%hDefaultPUs);
}

# parse_cpus_gpus_from_resource_list
#
# Get CPU and GPU counts from the node resource list
sub parse_cpus_gpus_from_resource_list {
   my ($sResourceList) = @_;
   my ($rescpus, $resgpus) = (0,0);
   my @asNodeSpecs = split /\+/, $sResourceList;
   foreach my $sNodeSpec (@asNodeSpecs){
      my ($sNodeHostOrCount, @asSpecList) = split /\:/, $sNodeSpec;
      my $nNodeCount = ($sNodeHostOrCount =~ /^\d+$/) ? $sNodeHostOrCount : 1;
      foreach my $sSpec (@asSpecList){
         my ($sKey, $nValue) = split /=/, $sSpec;
         if (lc($sKey) eq "ppn"){
            $rescpus += $nNodeCount * $nValue;
         }
         if (lc($sKey) eq "gpus"){
            $resgpus += $nNodeCount * $nValue;
         }
      }
   }
   return($rescpus, $resgpus);
}
