#!/usr/bin/perl

# 18.01.2010 12:52:40 EST
# Harm van Bakel <hvbakel@gmail.com>

# MODULES
use strict;
use warnings;
use Getopt::Long;
use Env '@PATH';

# GLOBAL
$ENV{QSTAT} ||= "qstat";
my @asStatusCodes = ('R','Q','H','T','W','S','E','C');
my %hStatusCodes  = ('R'=>'Running','Q'=>'Queued','H'=>'Held','T'=>'Moving',
                     'W'=>'Waiting','S'=>'Suspend','E'=>'Exiting','C'=>'Complete');

# GET PARAMETERS
my $flHelp       = 0;
my $flProcInfo   = 0;
my $flGpuInfo    = 0;
my $sServer      = "";
GetOptions("help!"      => \$flHelp,
           "cpuinfo!"   => \$flProcInfo,
           "gpuinfo!"   => \$flGpuInfo,
           "server:s"   => \$sServer);

# PRINT HELP
if ($flHelp) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName [-scgh]

   Gives a brief summary of all running and queued jobs.
   
   Options: 
    -s -server <string>
      Show queue information for a different server
    -c -cpuinfo
      Show processors in use rather than jobs
    -g -gpuinfo
      Show GPUs in use rather than jobs
    -h -help
      This help message
   
HELP
}


##########
## MAIN ##
##########

# Check whether the qstat binary exist in path
my $flQstatExists = grep -x "$_/$ENV{QSTAT}", @PATH;
die "Error: qstat is not installed on this system\n" unless($flQstatExists);

# Collect job or CPU count stats
my %hUserStats;
my %hQueueStats;
my %hTotalStats;
my $flPUinfo = $flProcInfo + $flGpuInfo;
my @asFailedCpuStats;
my $sQueueCmd = $sServer ? join('', $ENV{QSTAT}, ' @',$sServer) : $ENV{QSTAT};
if ($flPUinfo){
   my ($user,$queue,$status,$hostlist,$reslist,$ncpus) = ("","","","","","");
   open QSTAT, "$sQueueCmd -t -f -1 |" or die "Error: could not run 'qstat' to get job status report: $!\n";
   while (<QSTAT>){
      s/[\n\r]+$//;
      if(/^\s+Job_Owner = (\S+)@.*$/)        { $user     = $1; }
      if(/^\s+job_state = (\S)$/)            { $status   = $1; }
      if(/^\s+queue = (\S+)$/)               { $queue    = $1; }
      if(/^\s+exec_host = (.+)$/)            { $hostlist = $1; }
      if(/^\s+Resource_List.nodes = (.+)$/)  { $reslist  = $1; }
      if(/^\s+Resource_List.ncpus = (\d+)$/)  { $ncpus    = $1; }
      
      if ( (/^Job Id: / or eof) and $user){
         $user = "*\e[0;46m${user}\e[0m" if ($user eq $ENV{USER});
         my ($rescpus,$resgpus) = (0,0,0);
         
         # First try to obtain the number of CPUs and GPUs from the resource list
         if ($reslist){
            my @asNodeSpecs = split /\+/, $reslist;
            foreach my $sNodeSpec (@asNodeSpecs){
               my ($sNodeHostOrCount, @asSpecList) = split /\:/, $sNodeSpec;
               my $nNodeCount = ($sNodeHostOrCount =~ /^\d+$/) ? $sNodeHostOrCount : 1;
               foreach my $sSpec (@asSpecList){
                  my ($sKey, $nValue) = split /=/, $sSpec;
                  if (lc($sKey) eq "ppn"){
                     $rescpus += $nNodeCount * $nValue;
                  }
                  if (lc($sKey) eq "gpus"){
                     $resgpus += $nNodeCount * $nValue;
                  }
               }
            }
         }
         
         # Second, try to get the number of CPUs from the host list
         if ($rescpus==0 and $hostlist){
            my @cpus = split /\+/, $hostlist;
            $rescpus = scalar(@cpus);
         }
         
         # Third, try to parse the ncpu field if available
         if ($rescpus==0 and $ncpus){
            $rescpus = $ncpus;
         }
         
         # Check if we have collected any CPU or GPU info at this stage
         if ($rescpus==0 and $resgpus==0){
            push @asFailedCpuStats, "   $user   $status   $queue   $hostlist   $reslist   $ncpus";
         }
         
         # Collect all requested processing unit counts (gpus and/or cpus)
         my $nTotPUs = 0;
         $nTotPUs += $rescpus if ($flProcInfo);
         $nTotPUs += $resgpus if ($flGpuInfo);
         
         # Increment user stats
         $hUserStats{$user}{$queue}{$status} += $nTotPUs;
         $hQueueStats{$queue}{$status}       += $nTotPUs;
         $hTotalStats{$status}               += $nTotPUs;
         
         # Clear variables
         ($user,$queue,$status,$hostlist,$reslist,$ncpus) = ("","","","","","");
      }
   }
   close QSTAT;
}
else{
   open QSTAT, "$sQueueCmd -t |" or die "Error: could not run 'qstat' to get job status report: $!\n";
   while (<QSTAT>){
      next if (/^Job id/);
      next if (/^---/);
      s/[\n\r]+$//;
      my ($id,$job_name,$user,$time_elapsed,$status,$queue) = split /\s+/, $_, -1;
      if ($queue){
         $user = "*\e[0;46m${user}\e[0m" if ($user eq $ENV{USER});
         $hUserStats{$user}{$queue}{$status}++;
         $hQueueStats{$queue}{$status}++;
         $hTotalStats{$status}++;
      }
   }
   close QSTAT;
}

# Figure out which columns should be displayed
my @asJobStatus;
foreach my $sStatus (@asStatusCodes){
   push @asJobStatus, $sStatus if (exists $hTotalStats{$sStatus});
}

# Print header
my $sHeader = sprintf("%-12s %-14s", 'User', 'Queue');
foreach my $sStatus (@asJobStatus){
   $sHeader .= sprintf(" %-8s", $hStatusCodes{$sStatus});
}
print '=' x length($sHeader) . "\n$sHeader\n" . '-' x length($sHeader) . "\n";

# Print user stats
foreach my $user (sort(keys(%hUserStats))) {
   foreach my $queue (sort(keys(%{$hUserStats{$user}}))) {
      if ($user =~ /^\*/){
         my $formatted = $user;
         $formatted =~ s/^\*//;
         print sprintf("%-23s %-14s", $formatted, $queue);
      }
      else{
         print sprintf("%-12s %-14s", $user, $queue);
      }
      foreach my $status (@asJobStatus){
         if (exists($hUserStats{$user}{$queue}{$status})){
            print sprintf(" %-8s", $hUserStats{$user}{$queue}{$status});
         }
         else{
            print sprintf(" %-8s", 0);
         }
      }
      print "\n";
   }
}

# Print queue stats
print '-' x length($sHeader) . "\n";
foreach my $queue (sort(keys(%hQueueStats))) {
   print sprintf("%-12s %-14s", '', $queue);
   foreach my $status (@asJobStatus){
      if (exists($hQueueStats{$queue}{$status})){
         print sprintf(" %-8s", $hQueueStats{$queue}{$status});
      }
      else{
         print sprintf(" %-8s", 0);
      }
   }
   print "\n";
}

# Print totals
print " " x 13 . "-" x (length($sHeader)-13) . "\n";
print sprintf("%-12s %-14s", '', 'totals');
foreach my $status (@asJobStatus){
   if (exists($hTotalStats{$status})){
      print sprintf(" %-8s", $hTotalStats{$status});
   }
   else{
      print sprintf(" %-8s", 0);
   }
}
print "\n";

# Make sure we warn in case of issues with CPU counts
if (@asFailedCpuStats){
   my $nFailedCpuStats = scalar(@asFailedCpuStats);
   if ($nFailedCpuStats == 1){
      warn("Warning: could not determine accurate CPU or GPU counts for 1 job:\n")
   }
   else{
      warn("Warning: could not determine accurate CPU or GPU counts for $nFailedCpuStats jobs:\n")
   }
   foreach my $sFailedCpuStats (@asFailedCpuStats){
      warn("$sFailedCpuStats\n");
   }
}
