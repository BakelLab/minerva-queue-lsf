#!/usr/bin/perl

# 11.04.2010 11:33:45 EDT
# Harm van Bakel <hvbakel@gmail.com>

# GLOBALS
$ENV{PBS_OUTPUT}         ||= "$ENV{HOME}/pbs-output";   # Folder with pbs output files
$ENV{SUBMITJOB_CPUS}     ||= 1;                         # Default number of CPUs per node
$ENV{SUBMITJOB_CPUMEM}   ||= 3.8;                       # Default memory allocation per CPU in Gb
$ENV{SUBMITJOB_WALLTIME} ||= 24;                        # Default walltime in hours
$ENV{SUBMITJOB_NODES}    ||= 1;                         # Default number of nodes
$ENV{MAX_CPUS_PER_NODE}  ||= 64;                        # Maximum number of CPUs on a single node
$ENV{MAX_NODES}          ||= 123;                       # Maximum number of nodes in the cluster
$ENV{QSUB}               ||= 'qsub';                    # Location of qsub binary
$ENV{TEMPDIR}            ||= "/tmp";                    # Location of temp dir
$SIG{'INT'}=$SIG{'HUP'}=$SIG{'ABRT'}=$SIG{'QUIT'}=$SIG{'TRAP'}=$SIG{'STOP'}=\&INTERRUPT;

# MODULES
use strict;
use warnings;
use Cwd;
use File::Temp qw(tempfile tempdir);

##########
## MAIN ##
##########

# Print help message if called without arguments
if (@ARGV<1) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName [walltime] [-mpcnWqsk] { <command> | selfsched <file> }

   <command>
      The command to run on the cluster. Note that any output redirection 
      or pipe symbols must be escaped, i.e. \\> or \\|

   selfsched <file>
      File with commands (one per line) to run through the selfsched utility using
      the resources requested with submitjob
   
   Options: 
    walltime <integer>
       The expected run time of the job, measured in hours. Default: $ENV{SUBMITJOB_WALLTIME} 
    -c -cpu <integer>
       The number of CPUs required per node. Default: $ENV{SUBMITJOB_CPUS}
    -m -mem <integer>
       The maximum amount of memory used by the job in Gb. Default: $ENV{SUBMITJOB_CPUMEM} * (CPUs in job)
    -n -nodes <integer>
       The number of nodes required. Default: $ENV{SUBMITJOB_NODES}
    -q -queue <string>
       Target queue. Default: autoselect best queue
    -A -allocation <string>
       Allocation to use for this job
    -p -property <string>
       Restrict job to nodes with specified properties
    -W -additional <string>
       List additional qsub attributes
    -s -sem <string>
       Optional name of a file to append job IDs to
    -k -checkpoint
       Allow the job to be checkpointed

   Job STDERR will be merged with STDOUT and redirected to $ENV{PBS_OUTPUT}
   Any job exceeding the requested run time and memory limits will be killed automatically.
    
HELP
}

# Set up job output and TMP directories
unless (-e $ENV{PBS_OUTPUT}) { mkdir($ENV{PBS_OUTPUT}) or die "Could not create '$ENV{PBS_OUTPUT}' for pbs job output: $!\n"};

# Copy default settings
my $nTotalMem     = -1;
my $nCpus         = $ENV{SUBMITJOB_CPUS};
my $nNodes        = $ENV{SUBMITJOB_NODES};
my $nReqTime      = $ENV{SUBMITJOB_WALLTIME};

# Check submitjob arguments
my $flCheckForArgs = 1;
my $sProperty      = '';
my $sWalltime      = "$nReqTime:00:00";
my $sSemaphore     = "";
my $sAddAtrib      = "";
my $sQueue         = "";
my $flDebug        = 0;
my $flCheckpoint   = 0;
my $flSelfSched    = 0;
my $sAllocation    = '';
while($flCheckForArgs){
   if ($ARGV[0] =~ /^(\d+)\.*\d*$/){              # CPU time
      $nReqTime = shift @ARGV;
      my $nDecimal = $nReqTime - int($nReqTime);
      if ($nDecimal){
         my $nMin = int($nDecimal*60)+1;
         $sWalltime = "$1:$nMin:00";
      }
      else{
         $sWalltime = "$1:00:00";
      }
   }
   elsif($ARGV[0] =~ /(^-p)|(^--property)|(^-property)/){
      shift @ARGV;
      $sProperty = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-m)|(^--mem)|(^-mem)/){
      shift @ARGV;
      $nTotalMem = shift @ARGV;
      die "Error: amount of memory must be a number\n" unless($nTotalMem =~ /^\d+\.*\d*$/);
   }
   elsif($ARGV[0] =~ /(^-c)|(^--cpu)|(^-cpu)/){
      shift @ARGV;
      $nCpus = shift @ARGV;
      die "Error: number of CPUs per node must be between 1 and $ENV{MAX_CPUS_PER_NODE}\n" unless( ($nCpus =~ /^\d+$/) and ($nCpus >= 0) and ($nCpus <= $ENV{MAX_CPUS_PER_NODE}) );
   }
   elsif($ARGV[0] =~ /(^-n)|(^--nodes)|(^-nodes)/){
       shift @ARGV;
       $nNodes = shift @ARGV;
       die "Error: number of nodes must be between 1 and $ENV{MAX_NODES}\n" unless( ($nNodes =~ /^\d+$/) and ($nNodes >= 0) and ($nNodes <= $ENV{MAX_NODES}) );
   }
   elsif($ARGV[0] =~ /(^-s)|(^--sem)|(^-sem)/){
      shift @ARGV;
      $sSemaphore = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-W)|(^--additional)|(^-additional)/){
      shift @ARGV;
      $sAddAtrib = shift @ARGV;
   }
   elsif($ARGV[0] =~ /^--debug/){
      shift @ARGV;
      $flDebug = 1;
   }
   elsif($ARGV[0] =~ /(^-q)|(^--queue)|(^-queue)/){
       shift @ARGV;
       $sQueue = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-k)|(^--checkpoint)|(^-checkpoint)/){
       shift @ARGV;
       $flCheckpoint = 1;
   }
   elsif($ARGV[0] =~ /(^-A)|(^--allocation)|(^-allocation)/){
       shift @ARGV;
       $sAllocation = shift @ARGV;
   }
   elsif (lc($ARGV[0]) =~ /^selfsched/){
      shift @ARGV;
      $flSelfSched = 1;
   }
   else{
      $flCheckForArgs = 0;
   }
}

# Set up default memory allocation based on number of requested CPUs
if ($nTotalMem < 0){
   $nTotalMem = $nCpus * $ENV{SUBMITJOB_CPUMEM};
}

# Route jobs if no queue was specified
unless ($sQueue){
   if ($nCpus >0 and $nCpus < 32){
      $sQueue = "small";
   }
   elsif ($nCpus >=32 and $nCpus < 2048){
      $sQueue    = "medium";
      $nTotalMem = 0;
   }
   elsif ($nCpus >=2048){
      $sQueue    = "large";
      $nTotalMem = 0;
   }
   else{
      die "Error: None of the queues has the requested resources for this job\n";
   }
}

# Modify queue name if we're not running in an allocation
unless ($sAllocation){
   $sQueue = $sQueue . "_24hr" unless ($sQueue =~ /_24hr$/ or $sQueue =~ /intel/);
}

# Set the job resource list
my @asResources;
my $sTotalMem   = join('', int(1024*$nTotalMem), 'M');
my $nNcpus = $nNodes * $nCpus;
push @asResources, "walltime=$sWalltime" if ($sWalltime);
push @asResources, "mem=$sTotalMem"      if ($nTotalMem);
push @asResources, "prologue=$ENV{HOME}/.torque.prologue.sh" if (-e "$ENV{HOME}/.torque.prologue.sh");
push @asResources, "epilogue=$ENV{HOME}/.torque.epilogue.sh" if (-e "$ENV{HOME}/.torque.epilogue.sh");
if ($sProperty){
   push @asResources, "nodes=$nNodes:$sProperty:ppn=$nCpus";
}
else{
   push @asResources, "nodes=$nNodes:ppn=$nCpus";
}
my $sResources  = join(',', @asResources);
my $sPbsAttrib  = $sAddAtrib    ? "\n#PBS -W $sAddAtrib" : "";
my $sPbsQueue   = $sQueue       ? "\n#PBS -q $sQueue"  : "";
my $sPbsChkpt   = $flCheckpoint ? "\n#PBS -c enabled" : "";
my $sPbsAlloc   = $sAllocation  ? "\n#PBS -A $sAllocation" : "";
my $sPbsErrPath = $flCheckpoint ? "\n#PBS -e localhost:$ENV{PBS_OUTPUT}": "";

# Format the job name
my $sJobName = $ARGV[0];
$sJobName    =~ s/^ +//;  # Remove leading spaces
$sJobName    =~ s/ .*$//; # Remove anything following a space
$sJobName    =~ s/.*\///; # Remove the path before any command
$sJobName    =~ s/\&//;   # Remove any ampersands
$sJobName    =~ s/^\d+//; # Remove any leading digits, otherwise qsub will throw an error
$sJobName    =  substr($sJobName,0,14); # Make sure job name does not exceed max length

# Set up the job command depending on whether this is a self-scheduling run or an inline-command submission
my ($sJobCmd, $sJobFmt) = ("","");
if ($flSelfSched){
   die "Error: the 'selfsched' command only takes one argument as input\n" unless (@ARGV == 1);
   die "Error: the selfsched input file '$ARGV[0]' does not exist\n" unless (-e $ARGV[0]);
   $sJobCmd  = "module load selfsched\n";
   $sJobCmd .= "export fstatus=$sJobName.`echo \$PBS_JOBID | awk -F. '{print \$1}'`.selfsched.status\n";
   $sJobCmd .= "mpirun -np $nNcpus selfsched < $ARGV[0]";
   $sJobFmt  = "mpirun -np $nNcpus selfsched < $ARGV[0]";
}
else{
   # Do smart quoting, i.e. if arguments contain characters that were escaped in the input command,
   # make sure they are single-quoted in the output. This was added to facilitate submission of 
   # inline awk or matlab commands
   for (my $i=0 ; $i<@ARGV ; $i++ ){
      if ($ARGV[$i] =~ /'/){                                             # Handles matlab commands with single-quoted strings
         $ARGV[$i] = "\"$ARGV[$i]\"" unless ($ARGV[$i] =~ /^(\$|'|")/);  # double-quote argument unless it starts with $ (e.g. $'\t' ) or " or '
      }
      elsif ($ARGV[$i] =~ /[\${[\]!} ]/){                                # Handles awk, sed and other matlab commands
         $ARGV[$i] = "'$ARGV[$i]'" unless ($ARGV[$i] =~ /'/ or $ARGV[$i] =~/TMPSHMDIR/); # Single-quote unless it's already single-quoted or we're passing TMPSHMDIR as an argument
      }
      elsif ($ARGV[$i] eq 'awkt'){                                       # Alias for running awk with tab as separator
         $ARGV[$i] = 'awk -F \'\t\' -v OFS=\'\t\'';
      }
      elsif ($ARGV[$i] eq 'sortt'){                                      # Alias for running sort with tab as separator
         $ARGV[$i] = 'sort -t $\'\t\'';
      }
      else{
         # Nothing to see here, move along
      }
   }
   
   # Join arguments and optionally route through cr_run for checkpointing
   $sJobCmd =  join(' ', @ARGV);
   $sJobFmt =  $sJobCmd;
   $sJobFmt =~ s/\$/\\\$/g;  # Escape $, otherwise literal variables will be subsituted during 'echo'
   $sJobFmt =~ s/\"/\\\"/g;  # Escape ", otherwise they will be lost during 'echo'
}

# Write the job script to a temporary file
my $sCwd     =  getcwd;
my @asPath   =  split(/\//, $sCwd);
my $sExecDir =  pop @asPath;
my $sJoinOut =  $flCheckpoint ? 'n' : 'oe';
my ($fhTmpOut, $sTmpOut) = tempfile('submitjob-XXXXX', DIR=>$ENV{TEMPDIR}, UNLINK=>1);
print $fhTmpOut <<SUBMIT;
#!/bin/bash
#PBS -S /bin/bash
#PBS -o localhost:$ENV{PBS_OUTPUT}
#PBS -j $sJoinOut
#PBS -l $sResources
#PBS -m a
#PBS -r n
#PBS -V
#PBS -N $sJobName$sPbsAttrib$sPbsQueue$sPbsChkpt$sPbsAlloc$sPbsErrPath
cd $sCwd
export PBS_NCPU=$nCpus
echo -E '==> Run command    :' "$sJobFmt"
echo    '==> Execution host :' `hostname`
if [ -e /dev/shm/\$PBS_JOBID ]
then
   export TMPSHMDIR=/dev/shm/\$PBS_JOBID
else
   export TMPSHMDIR=\$TMPDIR
fi
$sJobCmd
SUBMIT
close $fhTmpOut;

# Submit job or print job submission script, depending on whether we're running in debug mode
if ($flDebug){
   open DEBUG, $sTmpOut or die "Error: can't open temporary qsub file\n";
   while (<DEBUG>){
      print;
   }
   close DEBUG;
}
else{
   # Now submit the job script and catch the job ID
   my $sJobID = "";
   open QSUB, "$ENV{QSUB} $sTmpOut|" or die "Error: can't execute qsub command: $!\n";
   while (<QSUB>){
      next if (/^\s*$/);
      next if (/^ *#/);
      s/[\n\r]+$//;
      $sJobID = $_;
      last;
   }
   close QSUB;
   
   # Write the job ID to the semaphore file if requested
   if ($sSemaphore){
      my $nJobID = $sJobID;
      $nJobID =~ s/\..*$//;
      $nReqTime = int($nReqTime/24)+1;
      open SEM, ">>$sSemaphore" or die "Error: could not write job ID to semaphore file";
      print SEM join("\t", $nJobID, $nReqTime), "\n";
      close SEM;
      warn "$sJobID written to $sSemaphore\n";
   }
   else{
      warn "$sJobID\n";
   }
}

#################
## SUBROUTINES ##
#################

# INTERRUPT
#
# Interrupt routine, make sure we exit gracefully for tmp file cleanup
sub INTERRUPT{
   exit(1); # This will call END
}
