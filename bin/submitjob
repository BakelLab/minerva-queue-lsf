#!/usr/bin/perl

# 11.04.2010 11:33:45 EDT
# Harm van Bakel <hvbakel@gmail.com>

# GLOBALS
$ENV{PBS_OUTPUT}         ||= "$ENV{HOME}/pbs-output";   # Folder with pbs output files
$ENV{SUBMITJOB_CPUS}     ||= 1;                         # Default number of CPUs per node
$ENV{SUBMITJOB_MEM}      ||= 3.8;                       # Default memory allocation in Gb
$ENV{SUBMITJOB_WALLTIME} ||= 24;                        # Default walltime in hours
$ENV{SUBMITJOB_NODES}    ||= 1;                         # Default number of nodes
$ENV{MAX_CPUS_PER_NODE}  ||= 64;                        # Maximum number of CPUs on a single node
$ENV{MAX_NODES}          ||= 123;                       # Maximum number of nodes in the cluster
$ENV{QSUB}               ||= 'qsub';                    # Location of qsub binary
$SIG{'INT'}=$SIG{'HUP'}=$SIG{'ABRT'}=$SIG{'QUIT'}=$SIG{'TRAP'}=$SIG{'STOP'}=\&INTERRUPT;

# MODULES
use strict;
use warnings;
use Cwd;
use File::Temp qw(tempfile tempdir);

##########
## MAIN ##
##########

# Print help message if called without arguments
if (@ARGV<1) {
   my $sScriptName = ($0 =~ /^.*\/(.+$)/) ? $1 : $0;
   die <<HELP

   Usage: $sScriptName [walltime] [-mpcnWqsk] <command>
   
   Options: 
    walltime <integer>
       The expected run time of the job, measured in hours. Default: $ENV{SUBMITJOB_WALLTIME}
    -m -mem <integer>
       The maximum amount of memory used by the job in Gb.  Default: $ENV{SUBMITJOB_MEM} 
    -p -property <string>
       Optionally request specific node properties.
    -c -cpu <integer>
       The number of CPUs required per node. Default: $ENV{SUBMITJOB_CPUS}
    -n -nodes <integer>
       The number of nodes required. Default: $ENV{SUBMITJOB_NODES}
    -W -additional <string>
       Additional attributes
    -q -queue <string>
       Target queue
    -s -sem <string>
       Optional name of a file to append job IDs to
    -k -checkpoint
       Allow the job to be checkpointed

    command
       The command to run on the cluster. Note that any output redirection 
       or pipe symbols must be escaped, i.e. \\> or \\|

   Job STDERR will be merged with STDOUT and redirected to $ENV{PBS_OUTPUT}
   Any job exceeding the run time and memory limits will be killed automatically.
    
HELP
}

# Set up job output and TMP directories
unless (-e $ENV{PBS_OUTPUT}) { mkdir($ENV{PBS_OUTPUT}) or die "Could not create '$ENV{PBS_OUTPUT}' for pbs job output: $!\n"};

# Copy default settings
my $nMem          = $ENV{SUBMITJOB_MEM};
my $nCpus         = $ENV{SUBMITJOB_CPUS};
my $nNodes        = $ENV{SUBMITJOB_NODES};
my $nReqTime      = $ENV{SUBMITJOB_WALLTIME};

# Check submitjob arguments
my $flCheckForArgs = 1;
my $sProperty      = '';
my $sWalltime      = "$nReqTime:00:00";
my $sSemaphore     = "";
my $sAddAtrib      = "";
my $sQueue         = "";
my $flDebug        = 0;
my $flCheckpoint   = 0;
while($flCheckForArgs){
   if ($ARGV[0] =~ /^(\d+)\.*\d*$/){              # CPU time
      $nReqTime = shift @ARGV;
      my $nDecimal = $nReqTime - int($nReqTime);
      if ($nDecimal){
         my $nMin = int($nDecimal*60)+1;
         $sWalltime = "$1:$nMin:00";
      }
      else{
         $sWalltime = "$1:00:00";
      }
   }
   elsif($ARGV[0] =~ /(^-p)|(^--property)|(^-property)/){
      shift @ARGV;
      $sProperty = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-m)|(^--mem)|(^-mem)/){
      shift @ARGV;
      $nMem = shift @ARGV;
      die "Error: amount of memory must be a number\n" unless($nMem =~ /^\d+\.*\d*$/);
   }
   elsif($ARGV[0] =~ /(^-c)|(^--cpu)|(^-cpu)/){
      shift @ARGV;
      $nCpus = shift @ARGV;
      die "Error: number of CPUs per node must be between 1 and $ENV{MAX_CPUS_PER_NODE}\n" unless( ($nCpus =~ /^\d+$/) and ($nCpus >= 0) and ($nCpus <= $ENV{MAX_CPUS_PER_NODE}) );
   }
   elsif($ARGV[0] =~ /(^-n)|(^--nodes)|(^-nodes)/){
       shift @ARGV;
       $nNodes = shift @ARGV;
       die "Error: number of nodes must be between 1 and $ENV{MAX_NODES}\n" unless( ($nNodes =~ /^\d+$/) and ($nNodes >= 0) and ($nNodes <= $ENV{MAX_NODES}) );
   }
   elsif($ARGV[0] =~ /(^-s)|(^--sem)|(^-sem)/){
      shift @ARGV;
      $sSemaphore = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-W)|(^--additional)|(^-additional)/){
      shift @ARGV;
      $sAddAtrib = shift @ARGV;
   }
   elsif($ARGV[0] =~ /^--debug/){
      shift @ARGV;
      $flDebug = 1;
   }
   elsif($ARGV[0] =~ /(^-q)|(^--queue)|(^-queue)/){
       shift @ARGV;
       $sQueue = shift @ARGV;
   }
   elsif($ARGV[0] =~ /(^-k)|(^--checkpoint)|(^-checkpoint)/){
       shift @ARGV;
       $flCheckpoint = 1;
   }
   else{
      $flCheckForArgs = 0;
   }
}

# Route jobs if no queue was specified
unless ($sQueue){
   if ($nCpus == 1){
      $sQueue ="serial";
   }
   elsif ($nCpus >1 and $nCpus < 32){
      $nCpus = 4 if $nCpus <4;
      $sQueue = "small";
   }
   elsif ($nCpus >=32 and $nCpus < 2048){
      $sQueue = "medium";
   }
   elsif ($nCpus >=2048){
      $sQueue = "large";
   }
   else{
      die "Error: None of the queues has the requested resources for this job\n";
   }
}

# Do smart quoting, i.e. if arguments contain characters that were escaped in the input command,
# make sure they are single-quoted in the output. This was added to facilitate submission of 
# inline awk or matlab commands
for (my $i=0 ; $i<@ARGV ; $i++ ){
   if ($ARGV[$i] =~ /'/){                                             # Handles matlab commands with single-quoted strings
      $ARGV[$i] = "\"$ARGV[$i]\"" unless ($ARGV[$i] =~ /^(\$|'|")/);  # double-quote argument unless it starts with $ (e.g. $'\t' ) or " or '
   }
   elsif ($ARGV[$i] =~ /[\${[\]!} ]/){                                # Handles awk, sed and other matlab commands
      $ARGV[$i] = "'$ARGV[$i]'" unless ($ARGV[$i] =~ /'/);            # Single-quote unless it's already single-quoted
   }
   elsif ($ARGV[$i] eq 'awkt'){                                       # Alias for running awk with tab as separator
      $ARGV[$i] = 'awk -F \'\t\' -v OFS=\'\t\'';
   }
   elsif ($ARGV[$i] eq 'sortt'){                                      # Alias for running sort with tab as separator
      $ARGV[$i] = 'sort -t $\'\t\'';
   }
   else{
      # Nothing to see here, move along
   }
}

# Format the job name to be the name of the command that is executed
my $sCwd     =  getcwd;
my @asPath   =  split(/\//, $sCwd);
my $sExecDir =  pop @asPath;
my $sJobName =  $ARGV[0];
$sJobName    =~ s/^ +//;  # Remove leading spaces
$sJobName    =~ s/ .*$//; # Remove anything following a space
$sJobName    =~ s/.*\///; # Remove the path before any command
$sJobName    =~ s/\&//;   # Remove any ampersands
$sJobName    =~ s/^\d+//; # Remove any leading digits, otherwise qsub will throw an error
$sJobName    =  substr($sJobName,0,14); # Make sure job name does not exceed max length

# Set the job resource list
my @asResources;
my $sMem   = join('', int(1024*$nMem), 'M');
my $nNcpus = $nNodes * $nCpus;
push @asResources, "walltime=$sWalltime" if ($sWalltime);
push @asResources, "mem=$sMem"           if ($nMem);
push @asResources, "prologue=$ENV{HOME}/.torque.prologue.sh" if (-e "$ENV{HOME}/.torque.prologue.sh");
push @asResources, "epilogue=$ENV{HOME}/.torque.epilogue.sh" if (-e "$ENV{HOME}/.torque.epilogue.sh");
if ($sProperty){
   push @asResources, "nodes=$nNodes:$sProperty:ppn=$nCpus";
}
else{
   push @asResources, "nodes=$nNodes:ppn=$nCpus";
}
my $sResources = join(',', @asResources);

# Add any additional attributes
my $sPbsAttrib = $sAddAtrib ? "\n#PBS -W $sAddAtrib" : "";
my $sPbsQueue  = $sQueue    ? "\n#PBS -q $sQueue"  : "";

# Write the job script to a temporary file
my $sJobCmd  = $flCheckpoint ? join(' ', 'cr_run', @ARGV) : join(' ', @ARGV);
my $sJobFmt  = $sJobCmd;
$sJobFmt     =~ s/\$/\\\$/g;  # Escape $, otherwise literal variables will be subsituted during 'echo'
$sJobFmt     =~ s/\"/\\\"/g;  # Escape ", otherwise they will be lost during 'echo'
my ($fhTmpOut, $sTmpOut) = tempfile('submitjob-XXXXX', DIR=>$ENV{TEMPDIR}, UNLINK=>1);
print $fhTmpOut <<SUBMIT;
#!/bin/bash
#PBS -S /bin/bash
#PBS -e localhost:$ENV{PBS_OUTPUT}
#PBS -o localhost:$ENV{PBS_OUTPUT}
#PBS -j oe
#PBS -l $sResources
#PBS -m a
#PBS -r n
#PBS -V
#PBS -N $sJobName$sPbsAttrib$sPbsQueue
cd $sCwd
export PBS_NCPU=$nCpus
echo -E '==> Run command    :' "$sJobFmt"
echo    '==> Execution host :' `hostname`
if [ -e /dev/shm/\$PBS_JOBID ]
then
   export TMPSHMDIR=/dev/shm/\$PBS_JOBID
else
   export TMPSHMDIR=\$TMPDIR
fi
$sJobCmd
SUBMIT
close $fhTmpOut;

# Check if we're running in debug mode
if ($flDebug){
   open DEBUG, $sTmpOut or die "Error: can't open temporary qsub file\n";
   while (<DEBUG>){
      print;
   }
   close DEBUG;
}
else{
   # Now submit the job script and catch the job ID
   my $sJobID = "";
   open QSUB, "$ENV{QSUB} $sTmpOut|" or die "Error: can't execute qsub command: $!\n";
   while (<QSUB>){
      next if (/^\s*$/);
      next if (/^ *#/);
      s/[\n\r]+$//;
      $sJobID = $_;
      last;
   }
   close QSUB;
   
   # Write the job ID to the semaphore file if requested
   if ($sSemaphore){
      my $nJobID = $sJobID;
      $nJobID =~ s/\..*$//;
      $nReqTime = int($nReqTime/24)+1;
      open SEM, ">>$sSemaphore" or die "Error: could not write job ID to semaphore file";
      print SEM join("\t", $nJobID, $nReqTime), "\n";
      close SEM;
      warn "$sJobID written to $sSemaphore\n";
   }
   else{
      warn "$sJobID\n";
   }
}

#################
## SUBROUTINES ##
#################

# INTERRUPT
#
# Interrupt routine, make sure we exit gracefully for tmp file cleanup
sub INTERRUPT{
   exit(1); # This will call END
}
